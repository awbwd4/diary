1. 상속, 포함관계
  - 상속은 부모 클래스를 상속하는것
  - 조상의 멤버는 좋든 싫든 모두 받는다
  - 포함은 클래스 내에서 다른 클래스를 호출하는것
  - 상속보다는 포함을 더 많이 씀

2. 상속
  - 상속은 단일 상속만을 허용함
  - 모든 클래스는 Object클래스를 상속받음(toString, equals 등)
  - println은 내부에서 toString을 호출함
  -  따라서 System.out.println(m)을 하게 되면 System.out.println(m.toString)과 같음

3. 오버라이딩
  - 선언부가 조상 클래스의 메서드와 일치해야
  - 접근 제어자를 조상 메서드 보다 좁게 할 수 없음. 조상이 public이면 public으로 해야함.
  - 예외는 조상클래스의 메서드보다 더 많이 할 수 없다. 조상 메서드의 예외가 1개이면 1개로 해야함

4. 참조변수 super
  - 객체 자신을 가리키는 참조변수, 인스턴스 메서드(생성자 포함) 내에만 존재한다. Static 메서드 내에서 사용 불가함.
  - 조상의 멤버를 자신의 멤버와 구별할 때 사용한다. 
  - this는 자신의 것, super는 조상의 것	

5. super() - 조상의 생성자
  - 자손클래스의 생성자에서 조상클래스의 생성자를 호출할 때가 있음.
  - 에러는 아니지만, 자손의 생성자는 자손 클래스에 선언이 된 변수만 초기화를 해야함. 
  - 조상클래스의 변수는 조상클래스의 생성자로 초기화를 해야.
  - 생성자의 첫줄에는 반드시 다른 생성자를 호출해야함. 없을 경우 컴파일러가 알아서 넣어주는거임
  - 상속을 했다면 첫줄에는 조상의 생성자를 super()로 호출
  - 상속을 안하는 클래스의 생성자라면? 그래도 컴파일러는 생성자의 첫줄에 super()를 자동으로 생성해줌, 이때의 super()의 대상은 Object()

6. 캡슐화
  - 멤버 변수에 직접 접근하면 안되고, 메서드를 통해 간접 접근 해야함(getter setter). 
  - 멤버 필드는 private, 멤버 메서드는 public.
  - 어떤 메서드가 생성된 클래스 내부에서만 쓰인다면, 접근 제어자는 private으로 하는 것이 좋다
  - 접근제어자는 private에서 하나씩 풀어내는게 좋음

7. 다형성
  - 조상타입의 참조변수로 자손타입의 객체를 다루는 것.
  - 조상 클래스에는 정의되지 않고 자손에만 정의되어 있는건 사용불가
